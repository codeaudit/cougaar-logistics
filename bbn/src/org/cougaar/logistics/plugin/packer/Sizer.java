/*
 * <copyright>
 *  
 *  Copyright 1999-2004 Honeywell Inc
 *  under sponsorship of the Defense Advanced Research Projects
 *  Agency (DARPA).
 * 
 *  You can redistribute this software and/or modify it under the
 *  terms of the Cougaar Open Source License as published on the
 *  Cougaar Open Source Website (www.cougaar.org).
 * 
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *  
 * </copyright>
 */

package org.cougaar.logistics.plugin.packer;

import org.cougaar.glm.ldm.asset.GLMAsset;
import org.cougaar.planning.ldm.PlanningFactory;
import org.cougaar.planning.ldm.measure.Mass;
import org.cougaar.planning.ldm.plan.AspectScorePoint;
import org.cougaar.planning.ldm.plan.AspectType;
import org.cougaar.planning.ldm.plan.AspectValue;
import org.cougaar.planning.ldm.plan.NewPrepositionalPhrase;
import org.cougaar.planning.ldm.plan.NewTask;
import org.cougaar.planning.ldm.plan.Preference;
import org.cougaar.planning.ldm.plan.PrepositionalPhrase;
import org.cougaar.planning.ldm.plan.ScoringFunction;
import org.cougaar.planning.ldm.plan.Task;
import org.cougaar.util.log.Logger;
import org.cougaar.util.log.Logging;

import java.util.ArrayList;
import java.util.Date;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.Vector;

/**
 * This class provides one of two "wheels" that drive the packing process.
 * This class provides a Generator that yields a stream of Tasks that
 * are components of the input tasks and that are sized per the
 * requirements that are generated by the Filler.
 * @see Filler
 */
class Sizer {
  protected long ONE_DAY_MILLIS = 24*60*60*1000;

  // no two tasks can have arrival dates farther than this time apart and
  // be on the same milvan
  protected long MAX_GROUP_DAYS = 2;
  
  static public final String TRUE = "True";

  /**
   * Unit for task quantity preference
   */
  static public final int TONS = 0;
  static public final int EACHES = 1;
  static public final int MIN_UNIT = 0;
  static public final int MAX_UNIT = 1;

  private static Logger logger = Logging.getLogger(Sizer.class);
  /**
   * How much of the quantity remains in the current task
   */
  private double _remainder;

  /**
   * The tasks we are packing from
   */
  private ArrayList _tasks;

  /**
   * As we break the current task, of the tasks to be packed,
   * into right-sized bits, we accumulate component tasks for
   * a subsidiary workflow in this SList.
   */
  private ArrayList _expansionQueue;

  /**
   * The task we are currently processing.
   */
  private Task _curTask;

  private GenericPlugin _gp;

  private int _quantityType;

  Sizer(ArrayList _packus, GenericPlugin gp, int quantityType) {
    _tasks = new ArrayList(_packus);
    _gp = gp;
    _remainder = 0.0;

    if ((quantityType < MIN_UNIT) ||
        (quantityType > MAX_UNIT)) {
      logger.error("Sizer: invalid quantity unit specified - " +
                   quantityType +
                   " - assuming TONS.");
      _quantityType = TONS;
    } else {
      _quantityType = quantityType;
    }
  }

  /**
   * there's more ammo left if the queue has something in it OR
   * we're on the last task (_curTask) and there's ammo left in it
   */
  public boolean moreTasksInQueue() {
    return !_tasks.isEmpty() || (_remainder > 0);
  }

  /**
   * The Filler will request some amount of quantity from the
   * Sizer.
   * This method will return a Task whose quantity is <= to requestedAmt,
   * or null if there are no more tasks to be packed.
   */
  Task provide(double requestedAmt, double earliest, double latest) {
    Task ret = null;

    // first, if we've gotten a request, we need to check
    // to see if the _curTask has anything left in it...
    if (_remainder == 0.0) {
      if ((_curTask = getNextTask()) != null) {
        // there is now one less task in _tasks b/c of getNextTask call
        Mass taskMass = getTaskMass(_curTask, _quantityType);
        _remainder = taskMass.getShortTons();

        if (_expansionQueue != null) {
          logger.error("Sizer.provide : ERROR - Expansion queue is not null - we will drop tasks :");
          for (Iterator iter = _expansionQueue.iterator(); iter.hasNext();)
            logger.error("\t" + ((Task) iter.next()).getUID());
        }
        _expansionQueue = new ArrayList();
      } else {
        logger.error("Sizer.provide : ERROR - no current task...");
        return null; // should never happen
      }
    }

    // return null if the current task is either completely before or after
    // the arrival window of the milvan we're aggregating

    Preference endDatePref = _curTask.getPreference(AspectType.END_TIME);
    ScoringFunction sf = endDatePref.getScoringFunction();
    AspectScorePoint aspStart = sf.getDefinedRange().getRangeStartPoint();
    Date taskEarlyDate = new Date((long) aspStart.getValue());
    if (taskEarlyDate.getTime() > latest) {
      return null;
    }

    AspectScorePoint aspEnd = sf.getDefinedRange().getRangeEndPoint();
    Date taskLateDate = new Date((long) aspEnd.getValue());
    if (taskLateDate.getTime() < earliest) {
      return null;
    }

    long bestArrival = (long) _curTask.getPreferredValue(AspectType.END_TIME);    
    
    if (earliest > 0 && // if we've ever made a milvan
	((bestArrival - earliest) > MAX_GROUP_DAYS*ONE_DAY_MILLIS ||
	 (latest - bestArrival)   > MAX_GROUP_DAYS*ONE_DAY_MILLIS)) {
      if (logger.isInfoEnabled ()) {
	logger.info("making a new milvan since task with best arrival of " +
		    new Date(bestArrival) + " outside of (earliest : " +
		    new Date((long)earliest) + "-> latest " +
		    new Date((long)latest) + ") window");
      }
      /*
      System.out.println ("making a new milvan since task with best arrival of " +
		    new Date(bestArrival) + " outside of (earliest : " +
		    new Date((long)earliest) + "-> latest " +
		    new Date((long)latest) + ") window");
      */

      return null;
    }

    // precondition:  _curTask is bound to a Task and remainder >= 0.0
    // remainder can be == 0.0 because some Plugin developers make such
    // tasks instead of rescinding requests.
    //System.out.println(" _remainder is " + _remainder + " requestedAmt " + requestedAmt);
    // if (_remainder < (requestedAmt + 0.1))
    if (_remainder <= requestedAmt) {
      // we are going to use up the entire _curTask and need to
      // take care of the expansion
      ret = sizedTask(_curTask, _remainder);
      _expansionQueue.add(0, ret);
      makeExpansion(_curTask, _expansionQueue);
      _expansionQueue = null; // it has been used - we shouldn't try to use it again
      _remainder = 0.0;
    } else {
      ret = sizedTask(_curTask, requestedAmt);
      _expansionQueue.add(0, ret);
      _remainder = _remainder - requestedAmt;
      if (_remainder == 0.0)
        logger.error("Sizer.provide : ERROR - We will drop task " + ret.getUID());
    }
    return ret;
  }

  /**
   * This method should only be called after areMoreTasks
   * has returned true; it does no safety checking itself.
   */
  private Task getNextTask() {
    if (!_tasks.isEmpty()) {
      Task t = (Task) _tasks.remove(0);
      return t;
    } else {
      return null;
    }
  }

  public int sizedMade = 0;

  /**
   * Returns a copy of the input task that is identical in every way,
   * but whose quantity has been set to size.
   * This task will <em>not</em> be published yet.
   */
  private Task sizedTask(Task t, double size) {
    PlanningFactory factory = _gp.getGPFactory();
    NewTask nt = factory.newTask();

    sizedMade++;

    nt.setVerb(t.getVerb());
    nt.setParentTask(t);
    nt.setDirectObject(factory.createInstance(t.getDirectObject()));

    // copy the PPs
    ArrayList preps = new ArrayList();
    Enumeration e = t.getPrepositionalPhrases();
    NewPrepositionalPhrase npp;
    while (e.hasMoreElements()) {
      npp = factory.newPrepositionalPhrase();
      PrepositionalPhrase pp = (PrepositionalPhrase) e.nextElement();
      npp.setPreposition(pp.getPreposition());
      npp.setIndirectObject(pp.getIndirectObject());
      preps.add(npp);
    }

    npp = factory.newPrepositionalPhrase();
    // Mark as INTERNAL so we recognize it as an expansion task.
    npp.setPreposition(GenericPlugin.INTERNAL);
    npp.setIndirectObject(TRUE);
    preps.add(npp);

    //BOZO
    nt.setPrepositionalPhrases(new Vector(preps).elements());

    // now copy the preferences, with the exception of quantity...
    ArrayList prefs = new ArrayList();
    e = t.getPreferences();
    while (e.hasMoreElements()) {
      Preference p = (Preference) e.nextElement();
      if (p.getAspectType() != AspectType.QUANTITY) {
        Preference np =
            factory.newPreference(p.getAspectType(),
                                  p.getScoringFunction(),
                                  p.getWeight());
        prefs.add(np);
      }
    }

    AspectValue av = AspectValue.newAspectValue(AspectType.QUANTITY, size);
    ScoringFunction sf = ScoringFunction.createNearOrBelow(av, 0.1);
    Preference pref = factory.newPreference(AspectType.QUANTITY, sf);
    prefs.add(0, pref);

    //BOZO
    nt.setPreferences(new Vector(prefs).elements());
    // TODO delme
    double provided = nt.getPreferredValue(AspectType.QUANTITY);
    if (provided != size)
      logger.info("requested " + size + " != quantity pref " + provided);
    return nt;
  }

  /**
   * Make an expansion by putting all the tasks in subtasks into a new
   * workflow and making them the workflow of expandme.  This can probably
   * be done using a method on the GenericPlugin.
   * @see GenericPlugin#createExpansion
   */
  private void makeExpansion(Task expandme, ArrayList subtasks) {
    _gp.createExpansion(subtasks.iterator(), expandme);
  }

  /**
   * Compute the mass associated with the task
   *
   */
  public static Mass getTaskMass(Task task, int quantityUnit) {
    switch (quantityUnit) {
      case (EACHES):
        GLMAsset assetToBePacked = (GLMAsset) task.getDirectObject();
        if (assetToBePacked.hasPhysicalPG()) {
          Mass massPerEach = assetToBePacked.getPhysicalPG().getMass();
          double taskWeight = task.getPreferredValue(AspectType.QUANTITY) *
              massPerEach.getShortTons();
          return new Mass(taskWeight, Mass.SHORT_TONS);
        } else {
          if (logger.isDebugEnabled()) {
            logger.debug("Sizer.getTaskMass: asset - " +
                         assetToBePacked +
                         " - does not have a PhysicalPG. " +
                         "Assuming QUANTITY preference is in stort tons.");
          }
          return new Mass(task.getPreferredValue(AspectType.QUANTITY),
                          Mass.SHORT_TONS);
        }

      case (TONS):
        return new Mass(task.getPreferredValue(AspectType.QUANTITY),
                        Mass.SHORT_TONS);

      default:
        logger.error("Sizer: invalid quantity unit specified - " +
                     quantityUnit +
                     " - assuming TONS.");
        return new Mass(task.getPreferredValue(AspectType.QUANTITY),
                        Mass.SHORT_TONS);
    }
  }
}
